/*	main.cpp - Entry point dell'applicazione.	Configurazione dell'ambiente OpenGl */#include <stdio.h>#include <stdlib.h>#include <time.h>#include <math.h>#include <iostream>using namespace std;// Inclusione di OpenGL/GLUT cross platform#if defined __APPLE__    #include <OpenGL/gl.h>    #include <OpenGL/glu.h>    #include <GLUT/glut.h>#else    #include <GL/gl.h>    #include <GL/glu.h>    #include <GL/glut.h>#endif#include "block.h"#include "maze.h"#include "textureBMP.h"#define ASPECT_RATIO 1.0fvoid CambiaDim(int, int);void DisegnaTutto();void Azione(unsigned char key, int x, int y);float AngoloX = 0;float AngoloY = 0;GLfloat X = 1.0f; // x osservatoreGLfloat Z =	1.0f; // z osservatoreGLfloat A = -130; // angolo osservatoreGLfloat Y = 0.5f; // y osservatoreGLubyte Texture1[512 * 512 * 3];GLubyte Texture2[512 * 512 * 3];GLubyte* Texture3;Maze* m;void CambiaDim(int ww, int wh){	float war = (float)ww / (float)wh; // Window aspect ratio	int vw, vh; // Viewport width e height	int x = 0, y = 0;	cout <<war <<" "<< ASPECT_RATIO<<endl;	if (war > ASPECT_RATIO) {// La finestra è più larga		vh = wh;		vw = vh * ASPECT_RATIO;		x = (ww - vw)/2;	} else { // la finestra è più alta		vw = ww;		vh = vw * (1/ASPECT_RATIO);		y = (wh- vh) /2;	}	glViewport(x, y, vw, vh);	glMatrixMode(GL_PROJECTION);	glLoadIdentity();	/*		glFrustum ( left, right, bottom, top, nearVal, farVal)	*/	glFrustum(-0.5f, 0.5f, -0.5f, 0.5f, 1.0f, 100);	}GLfloat PosLite[4] = { 2, 2, 2, 1 };void DisegnaTutto(){	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	glMatrixMode(GL_MODELVIEW);	glLoadIdentity();		// Rototraslazione inversa	glRotatef(-A, 0, 1, 0);	//glRotatef(90, 1, 0, 0); // Vista dall'alto	glTranslatef(-X, -Y, -Z); // il -2.0f è per stare più in alto	// luci	GLfloat aLite[4] = { 0.0, 0.0, 0.0, 1 };	GLfloat dLite[4] = { 1.0, 1.0, 1.0, 1 };	GLfloat sLite[4] = { 0, 0, 0, 1 };		GLfloat d2Lite[4] = { 0.0, 0.0, 1.0, 1 };	GLfloat Pos2Lite[4] = { -2, 2, 2, 1 };		glLightfv(GL_LIGHT0, GL_AMBIENT, aLite);	glLightfv(GL_LIGHT0, GL_DIFFUSE, dLite);	glLightfv(GL_LIGHT0, GL_SPECULAR, sLite);		glLightfv(GL_LIGHT1, GL_AMBIENT, aLite);	glLightfv(GL_LIGHT1, GL_DIFFUSE, d2Lite);	glLightfv(GL_LIGHT1, GL_SPECULAR, sLite);		glLightfv(GL_LIGHT0, GL_POSITION, PosLite);		glLightfv(GL_LIGHT1, GL_POSITION, Pos2Lite);		//glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);	//glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);		// materiale	GLfloat ambiente[4] = { 1, 1, 1, 1 };	GLfloat direttiva[4] = { 1, 1, 1, 1 };	GLfloat brillante[4] = { 0, 0, 0, 1 };		glMateriali(GL_FRONT, GL_SHININESS, 32);		glMaterialfv(GL_FRONT, GL_AMBIENT, ambiente);	glMaterialfv(GL_FRONT, GL_DIFFUSE, direttiva);	glMaterialfv(GL_FRONT, GL_SPECULAR, brillante);			// Disegna il labirinto	m->draw();		glutSwapBuffers();	cout <<"Posizione camera: ";    cout << X <<" " <<Z <<" " <<A <<endl;}void Azione(unsigned char a, int , int ){	if(a == 'a') X -= 0.1f;	if(a == 'd') X += 0.1f;	if(a == 's') Z += 0.1f;	if(a == 'w') Z -= 0.1f;	if(a == 'e') A -= 10;	if(a == 'q') A += 10;		if(a == 'y') PosLite[2] += 0.5f;	if(a == 'b') PosLite[2] -= 0.5f;		if(a == 27) exit(0); // ESC per uscire	glutPostRedisplay();}int main(int argc, char **argv){	glutInit(&argc, argv);	glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);	glutInitWindowPosition(100, 100);	glutInitWindowSize(400, 400);	glutCreateWindow("MazeRunner");		glEnable(GL_DEPTH_TEST);	glClearColor(0, 0, 0, 1.0f);	glEnable(GL_CULL_FACE);		glEnable(GL_LIGHTING);	//glEnable(GL_LIGHT0);	//glEnable(GL_LIGHT1);		GLfloat white[4] = { 1, 1, 1, 1 };		glLightModelfv(GL_LIGHT_MODEL_AMBIENT, white);	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);			glutReshapeFunc(CambiaDim);	glutKeyboardFunc(Azione);	glutDisplayFunc(DisegnaTutto);		m = new Maze();	glutMainLoop();		return(0);}