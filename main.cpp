/*	main.cpp - Entry point dell'applicazione.	Configurazione dell'ambiente OpenGl */#include <stdio.h>#include <stdlib.h>#include <time.h>#include <math.h>#include <iostream>using namespace std;// Inclusione di OpenGL/GLUT cross platform#if defined __APPLE__    #include <OpenGL/gl.h>    #include <OpenGL/glu.h>    #include <GLUT/glut.h>#else    #include <GL/gl.h>    #include <GL/glu.h>    #include <GL/glut.h>#endif#include "block.h"#include "maze.h"#include "textureBMP.h"#define ASPECT_RATIO 1.0f#define PI 3.141592653void handleResize(int, int);void drawScene();bool detectCollision();void handleKeyDown(unsigned char key, int x, int y);void handleKeyUp(unsigned char key, int x, int y);// Mantiene in memoria i tasti premuti // (nel caso ci siano più tasti premuti contemporanemante)bool* keyStates = new bool[256];int pressedKeys = 0;GLfloat X = 1.0f; // x osservatoreGLfloat Z =	1.0f; // z osservatoreGLfloat A = 0; // angolo osservatore rispetto l'asse YGLfloat Y = 0.5f; // y osservatore// LabirintoMaze* m;void handleResize(int ww, int wh){	float war = (float)ww / (float)wh; // Window aspect ratio	int vw, vh; // Viewport width e height	int x = 0, y = 0;	cout <<war <<" "<< ASPECT_RATIO<<endl;	if (war > ASPECT_RATIO) {// La finestra è più larga		vh = wh;		vw = vh * ASPECT_RATIO;		x = (ww - vw)/2;	} else { // la finestra è più alta		vw = ww;		vh = vw * (1/ASPECT_RATIO);		y = (wh- vh) /2;	}	glViewport(x, y, vw, vh);	glMatrixMode(GL_PROJECTION);	glLoadIdentity();	/*		glFrustum ( left, right, bottom, top, nearVal, farVal)		Da problemi sul clipping dei punti.		Conviene usare gluPrespective 		https://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml	*/	//glFrustum(-0.5f, 0.5f, -0.5f, 0.5f, 1.0f, 100);	gluPerspective(70.0f, ASPECT_RATIO, 0.05f, 100);}	GLfloat PosLite[4] = { 2, 2, 2, 1 };void drawScene(){	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	glMatrixMode(GL_MODELVIEW);	glLoadIdentity();		// Rototraslazione inversa	glRotatef(-A, 0, 1, 0);	//glRotatef(90, 1, 0, 0); // Vista dall'alto	glTranslatef(-X, -Y, -Z); // il -2.0f è per stare più in alto	// luci	GLfloat aLite[4] = { 1.0f, 1.0f, 1.0f, 1 };	GLfloat dLite[4] = { 0.4f, 0.4f, 0.4f, 1 };	GLfloat sLite[4] = { 0.1f, 0.1f, 0.1f, 1 };		glLightfv(GL_LIGHT0, GL_AMBIENT, aLite);	glLightfv(GL_LIGHT0, GL_DIFFUSE, dLite);	glLightfv(GL_LIGHT0, GL_SPECULAR, sLite);	//	//glLightfv(GL_LIGHT1, GL_AMBIENT, aLite);	//glLightfv(GL_LIGHT1, GL_DIFFUSE, d2Lite);	//glLightfv(GL_LIGHT1, GL_SPECULAR, sLite);		// Specific spot effects    // Cut off angle is 60 degrees    glLightf(GL_LIGHT0,GL_SPOT_CUTOFF, 60.0f);    // Fairly shiny spot    glLightf(GL_LIGHT0,GL_SPOT_EXPONENT,4.0f);    GLfloat PosLite[4] = { -X, -Y, -Z, 1 };	glLightfv(GL_LIGHT0, GL_POSITION, PosLite);	GLfloat light_direction[] = { 1,1,1};	glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION,light_direction);		//glLightfv(GL_LIGHT1, GL_POSITION, Pos2Lite);		//glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);	//glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);		// materiale	GLfloat ambiente[4] = { 0.5f, 0.5f, 0.5f, 1 };	GLfloat direttiva[4] = { 1, 1, 1, 1 };	GLfloat brillante[4] = { 0, 0, 0, 1 };		glMateriali(GL_FRONT, GL_SHININESS, 32);		glMaterialfv(GL_FRONT, GL_AMBIENT, ambiente);	glMaterialfv(GL_FRONT, GL_DIFFUSE, direttiva);	glMaterialfv(GL_FRONT, GL_SPECULAR, brillante);			// Disegna il labirinto	m->draw();		glutSwapBuffers();	cout <<"Posizione camera: ";    cout <<"X:"<< X <<" Z: " <<Z <<" A: " <<A <<endl;}void handleKeyDown(unsigned char key, int , int ){		keyStates[key] = true; 	// variabili per ripristinare la poszione in caso di collisione	float oldX = X;	float oldZ = Z;	// A è la rotazione sull'asse Y espressa in gradi	// cresce in negativo se giro verso destra	if(keyStates[(int)'e']) A -= 10; // Gira a destra	if(keyStates[(int)'q']) A += 10; // Gira a sinistra	float radA = A * PI/180.0f;	//cout << "COS A " << cos(radA) <<" SIN -A: " <<sin(-radA) <<endl;		if(keyStates[(int)'a']) { // Laterale a sinistra		Z += 0.1f * sin(radA);		X -= 0.1f * cos(radA);	}	if(keyStates[(int)'d']) { // Laterale a destra		Z -= 0.1f * sin(radA);		X += 0.1f * cos(radA);	}	if(keyStates[(int)'w']) { // Avanti		cout << "AVANTI"<<endl;		Z -= 0.1f * cos(radA);		X += 0.1f * sin(-radA);	}	//if(key == 's') { // Indietro	if(keyStates[(int)'s']) { // Indietro		Z += 0.1f * cos(radA);		X -= 0.1f * sin(-radA);	}	if(key == 'y') PosLite[2] += 0.5f;	if(key == 'b') PosLite[2] -= 0.5f;		if(key == 27) exit(0); // ESC per uscire	if (detectCollision()){		X = oldX;		Z = oldZ;	}	glutPostRedisplay();}bool detectCollision() {	// X Z	// m labiritino	float allowedOffest = 0.4f; //massima distanza dal centro consentita	int x,z;	x = round(X);	z = round(Z);	cout << "SONO IN "<<x <<" "<<z<<endl;	if (m->isWall(x,z)){ return true;} // Sono finito dentro al muro	if (m->isWall(x+1,z) && X > x+allowedOffest){ // collisione con muro a destra		cout <<"Collisione a destra"<<endl;		return true;	}	if (m->isWall(x-1,z) && X < x-allowedOffest) { // collisione con muro a sinsitra		cout <<"Collisione a sinsitra"<<endl;		return true;	}	if (m->isWall(x, z+1) && Z > z+allowedOffest) { // collisione con muro in basso		cout <<"Collisione in basso"<<endl;		return true;	}	if (m->isWall(x, z-1) && Z < z-allowedOffest) { // collisione con muro in alto		cout <<"Collisione in alto"<<endl;		return true;	}	return false;}void handleKeyUp(unsigned char key, int x, int y) {	keyStates[key] = false;}int main(int argc, char **argv){	glutInit(&argc, argv);	glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);	glutInitWindowPosition(100, 100);	glutInitWindowSize(400, 400);	glutCreateWindow("MazeRunner");		glEnable(GL_DEPTH_TEST);	glClearColor(0, 0, 0, 1.0f);	glEnable(GL_CULL_FACE);		glEnable(GL_LIGHTING);	glEnable(GL_LIGHT0);	//glEnable(GL_LIGHT1);		// Luce ambientale	GLfloat ambientLight[4] = { 0.2f, 0.2f, 0.2f, 1 };	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0); //luce solo sul lato principale dei poligoni			glutReshapeFunc(handleResize);	glutKeyboardFunc(handleKeyDown);	glutKeyboardUpFunc(handleKeyUp);	glutDisplayFunc(drawScene);		m = new Maze();	glutMainLoop();		return(0);}